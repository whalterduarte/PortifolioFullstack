"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stripe";
exports.ids = ["vendor-chunks/@stripe"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressElement: () => (/* binding */ AddressElement),\n/* harmony export */   AffirmMessageElement: () => (/* binding */ AffirmMessageElement),\n/* harmony export */   AfterpayClearpayMessageElement: () => (/* binding */ AfterpayClearpayMessageElement),\n/* harmony export */   AuBankAccountElement: () => (/* binding */ AuBankAccountElement),\n/* harmony export */   CardCvcElement: () => (/* binding */ CardCvcElement),\n/* harmony export */   CardElement: () => (/* binding */ CardElement),\n/* harmony export */   CardExpiryElement: () => (/* binding */ CardExpiryElement),\n/* harmony export */   CardNumberElement: () => (/* binding */ CardNumberElement),\n/* harmony export */   CartElement: () => (/* binding */ CartElement),\n/* harmony export */   Elements: () => (/* binding */ Elements),\n/* harmony export */   ElementsConsumer: () => (/* binding */ ElementsConsumer),\n/* harmony export */   EpsBankElement: () => (/* binding */ EpsBankElement),\n/* harmony export */   FpxBankElement: () => (/* binding */ FpxBankElement),\n/* harmony export */   IbanElement: () => (/* binding */ IbanElement),\n/* harmony export */   IdealBankElement: () => (/* binding */ IdealBankElement),\n/* harmony export */   LinkAuthenticationElement: () => (/* binding */ LinkAuthenticationElement),\n/* harmony export */   P24BankElement: () => (/* binding */ P24BankElement),\n/* harmony export */   PayButtonElement: () => (/* binding */ PayButtonElement),\n/* harmony export */   PaymentElement: () => (/* binding */ PaymentElement),\n/* harmony export */   PaymentMethodMessagingElement: () => (/* binding */ PaymentMethodMessagingElement),\n/* harmony export */   PaymentRequestButtonElement: () => (/* binding */ PaymentRequestButtonElement),\n/* harmony export */   ShippingAddressElement: () => (/* binding */ ShippingAddressElement),\n/* harmony export */   useCartElement: () => (/* binding */ useCartElement),\n/* harmony export */   useCartElementState: () => (/* binding */ useCartElementState),\n/* harmony export */   useElements: () => (/* binding */ useElements),\n/* harmony export */   useStripe: () => (/* binding */ useStripe)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar usePrevious = function usePrevious(value) {\n    var ref = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(value);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref.current;\n};\nvar isUnknownObject = function isUnknownObject(raw) {\n    return raw !== null && _typeof(raw) === \"object\";\n};\nvar isPromise = function isPromise(raw) {\n    return isUnknownObject(raw) && typeof raw.then === \"function\";\n}; // We are using types to enforce the `stripe` prop in this lib,\n// but in an untyped integration `stripe` could be anything, so we need\n// to do some sanity validation to prevent type errors.\nvar isStripe = function isStripe(raw) {\n    return isUnknownObject(raw) && typeof raw.elements === \"function\" && typeof raw.createToken === \"function\" && typeof raw.createPaymentMethod === \"function\" && typeof raw.confirmCardPayment === \"function\";\n};\nvar PLAIN_OBJECT_STR = \"[object Object]\";\nvar isEqual = function isEqual(left, right) {\n    if (!isUnknownObject(left) || !isUnknownObject(right)) {\n        return left === right;\n    }\n    var leftArray = Array.isArray(left);\n    var rightArray = Array.isArray(right);\n    if (leftArray !== rightArray) return false;\n    var leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;\n    var rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;\n    if (leftPlainObject !== rightPlainObject) return false; // not sure what sort of special object this is (regexp is one option), so\n    // fallback to reference check.\n    if (!leftPlainObject && !leftArray) return left === right;\n    var leftKeys = Object.keys(left);\n    var rightKeys = Object.keys(right);\n    if (leftKeys.length !== rightKeys.length) return false;\n    var keySet = {};\n    for(var i = 0; i < leftKeys.length; i += 1){\n        keySet[leftKeys[i]] = true;\n    }\n    for(var _i = 0; _i < rightKeys.length; _i += 1){\n        keySet[rightKeys[_i]] = true;\n    }\n    var allKeys = Object.keys(keySet);\n    if (allKeys.length !== leftKeys.length) {\n        return false;\n    }\n    var l = left;\n    var r = right;\n    var pred = function pred(key) {\n        return isEqual(l[key], r[key]);\n    };\n    return allKeys.every(pred);\n};\nvar extractAllowedOptionsUpdates = function extractAllowedOptionsUpdates(options, prevOptions, immutableKeys) {\n    if (!isUnknownObject(options)) {\n        return null;\n    }\n    return Object.keys(options).reduce(function(newOptions, key) {\n        var isUpdated = !isUnknownObject(prevOptions) || !isEqual(options[key], prevOptions[key]);\n        if (immutableKeys.includes(key)) {\n            if (isUpdated) {\n                console.warn(\"Unsupported prop change: options.\".concat(key, \" is not a mutable property.\"));\n            }\n            return newOptions;\n        }\n        if (!isUpdated) {\n            return newOptions;\n        }\n        return _objectSpread2(_objectSpread2({}, newOptions || {}), {}, _defineProperty({}, key, options[key]));\n    }, null);\n};\nvar INVALID_STRIPE_ERROR = \"Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\"; // We are using types to enforce the `stripe` prop in this lib, but in a real\n// integration `stripe` could be anything, so we need to do some sanity\n// validation to prevent type errors.\nvar validateStripe = function validateStripe(maybeStripe) {\n    if (maybeStripe === null || isStripe(maybeStripe)) {\n        return maybeStripe;\n    }\n    throw new Error(INVALID_STRIPE_ERROR);\n};\nvar parseStripeProp = function parseStripeProp(raw) {\n    if (isPromise(raw)) {\n        return {\n            tag: \"async\",\n            stripePromise: Promise.resolve(raw).then(validateStripe)\n        };\n    }\n    var stripe = validateStripe(raw);\n    if (stripe === null) {\n        return {\n            tag: \"empty\"\n        };\n    }\n    return {\n        tag: \"sync\",\n        stripe: stripe\n    };\n};\nvar ElementsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nElementsContext.displayName = \"ElementsContext\";\nvar parseElementsContext = function parseElementsContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n    }\n    return ctx;\n};\nvar CartElementContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nCartElementContext.displayName = \"CartElementContext\";\nvar parseCartElementContext = function parseCartElementContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n    }\n    return ctx;\n};\n/**\n * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.\n * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.\n *\n * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.\n * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.\n * Pass the returned `Promise` to `Elements`.\n *\n * @docs https://stripe.com/docs/stripe-js/react#elements-provider\n */ var Elements = function Elements(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return parseStripeProp(rawStripeProp);\n    }, [\n        rawStripeProp\n    ]);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), cart = _React$useState2[0], setCart = _React$useState2[1];\n    var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), cartState = _React$useState4[0], setCartState = _React$useState4[1]; // For a sync stripe instance, initialize into context\n    var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0___default().useState(function() {\n        return {\n            stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n            elements: parsed.tag === \"sync\" ? parsed.stripe.elements(options) : null\n        };\n    }), _React$useState6 = _slicedToArray(_React$useState5, 2), ctx = _React$useState6[0], setContext = _React$useState6[1];\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var isMounted = true;\n        var safeSetContext = function safeSetContext(stripe) {\n            setContext(function(ctx) {\n                // no-op if we already have a stripe instance (https://github.com/stripe/react-stripe-js/issues/296)\n                if (ctx.stripe) return ctx;\n                return {\n                    stripe: stripe,\n                    elements: stripe.elements(options)\n                };\n            });\n        }; // For an async stripePromise, store it in context once resolved\n        if (parsed.tag === \"async\" && !ctx.stripe) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe && isMounted) {\n                    // Only update Elements context if the component is still mounted\n                    // and stripe is not null. We allow stripe to be null to make\n                    // handling SSR easier.\n                    safeSetContext(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !ctx.stripe) {\n            // Or, handle a sync stripe instance going from null -> populated\n            safeSetContext(parsed.stripe);\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed,\n        ctx,\n        options\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Apply updates to elements when options prop has relevant changes\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (!ctx.elements) {\n            return;\n        }\n        var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n            \"clientSecret\",\n            \"fonts\"\n        ]);\n        if (updates) {\n            ctx.elements.update(updates);\n        }\n    }, [\n        options,\n        prevOptions,\n        ctx.elements\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var anyStripe = ctx.stripe;\n        if (!anyStripe || !anyStripe._registerWrapper || !anyStripe.registerAppInfo) {\n            return;\n        }\n        anyStripe._registerWrapper({\n            name: \"react-stripe-js\",\n            version: \"1.16.5\"\n        });\n        anyStripe.registerAppInfo({\n            name: \"react-stripe-js\",\n            version: \"1.16.5\",\n            url: \"https://stripe.com/docs/stripe-js/react\"\n        });\n    }, [\n        ctx.stripe\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ElementsContext.Provider, {\n        value: ctx\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CartElementContext.Provider, {\n        value: {\n            cart: cart,\n            setCart: setCart,\n            cartState: cartState,\n            setCartState: setCartState\n        }\n    }, children));\n};\nElements.propTypes = {\n    stripe: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().any),\n    options: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)\n};\nvar useElementsContextWithUseCase = function useElementsContextWithUseCase(useCaseMessage) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(ElementsContext);\n    return parseElementsContext(ctx, useCaseMessage);\n};\nvar useCartElementContextWithUseCase = function useCartElementContextWithUseCase(useCaseMessage) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(CartElementContext);\n    return parseCartElementContext(ctx, useCaseMessage);\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#useelements-hook\n */ var useElements = function useElements() {\n    var _useElementsContextWi = useElementsContextWithUseCase(\"calls useElements()\"), elements = _useElementsContextWi.elements;\n    return elements;\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook\n */ var useStripe = function useStripe() {\n    var _useElementsContextWi2 = useElementsContextWithUseCase(\"calls useStripe()\"), stripe = _useElementsContextWi2.stripe;\n    return stripe;\n};\n/**\n * @docs https://stripe.com/docs/payments/checkout/cart-element\n */ var useCartElement = function useCartElement() {\n    var _useCartElementContex = useCartElementContextWithUseCase(\"calls useCartElement()\"), cart = _useCartElementContex.cart;\n    return cart;\n};\n/**\n * @docs https://stripe.com/docs/payments/checkout/cart-element\n */ var useCartElementState = function useCartElementState() {\n    var _useCartElementContex2 = useCartElementContextWithUseCase(\"calls useCartElementState()\"), cartState = _useCartElementContex2.cartState;\n    return cartState;\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#elements-consumer\n */ var ElementsConsumer = function ElementsConsumer(_ref2) {\n    var children = _ref2.children;\n    var ctx = useElementsContextWithUseCase(\"mounts <ElementsConsumer>\"); // Assert to satisfy the busted React.FC return type (it should be ReactNode)\n    return children(ctx);\n};\nElementsConsumer.propTypes = {\n    children: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func).isRequired\n};\nvar useAttachEvent = function useAttachEvent(element, event, cb) {\n    var cbDefined = !!cb;\n    var cbRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(cb); // In many integrations the callback prop changes on each render.\n    // Using a ref saves us from calling element.on/.off every render.\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        cbRef.current = cb;\n    }, [\n        cb\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (!cbDefined || !element) {\n            return function() {};\n        }\n        var decoratedCb = function decoratedCb() {\n            if (cbRef.current) {\n                cbRef.current.apply(cbRef, arguments);\n            }\n        };\n        element.on(event, decoratedCb);\n        return function() {\n            element.off(event, decoratedCb);\n        };\n    }, [\n        cbDefined,\n        event,\n        element,\n        cbRef\n    ]);\n};\nvar capitalized = function capitalized(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nvar createElementComponent = function createElementComponent(type, isServer) {\n    var displayName = \"\".concat(capitalized(type), \"Element\");\n    var ClientElement = function ClientElement(_ref) {\n        var id = _ref.id, className = _ref.className, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, onBlur = _ref.onBlur, onFocus = _ref.onFocus, onReady = _ref.onReady, onChange = _ref.onChange, onEscape = _ref.onEscape, onClick = _ref.onClick, onLoadError = _ref.onLoadError, onLoaderStart = _ref.onLoaderStart, onNetworksChange = _ref.onNetworksChange, onCheckout = _ref.onCheckout, onLineItemClick = _ref.onLineItemClick, onConfirm = _ref.onConfirm, onCancel = _ref.onCancel, onShippingAddressChange = _ref.onShippingAddressChange, onShippingRateChange = _ref.onShippingRateChange;\n        var _useElementsContextWi = useElementsContextWithUseCase(\"mounts <\".concat(displayName, \">\")), elements = _useElementsContextWi.elements;\n        var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), element = _React$useState2[0], setElement = _React$useState2[1];\n        var elementRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n        var domNode = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n        var _useCartElementContex = useCartElementContextWithUseCase(\"mounts <\".concat(displayName, \">\")), setCart = _useCartElementContex.setCart, setCartState = _useCartElementContex.setCartState; // For every event where the merchant provides a callback, call element.on\n        // with that callback. If the merchant ever changes the callback, removes\n        // the old callback with element.off and then call element.on with the new one.\n        useAttachEvent(element, \"blur\", onBlur);\n        useAttachEvent(element, \"focus\", onFocus);\n        useAttachEvent(element, \"escape\", onEscape);\n        useAttachEvent(element, \"click\", onClick);\n        useAttachEvent(element, \"loaderror\", onLoadError);\n        useAttachEvent(element, \"loaderstart\", onLoaderStart);\n        useAttachEvent(element, \"networkschange\", onNetworksChange);\n        useAttachEvent(element, \"lineitemclick\", onLineItemClick);\n        useAttachEvent(element, \"confirm\", onConfirm);\n        useAttachEvent(element, \"cancel\", onCancel);\n        useAttachEvent(element, \"shippingaddresschange\", onShippingAddressChange);\n        useAttachEvent(element, \"shippingratechange\", onShippingRateChange);\n        var readyCallback;\n        if (type === \"cart\") {\n            readyCallback = function readyCallback(event) {\n                setCartState(event);\n                onReady && onReady(event);\n            };\n        } else if (onReady) {\n            if (type === \"payButton\") {\n                // Passes through the event, which includes visible PM types\n                readyCallback = onReady;\n            } else {\n                // For other Elements, pass through the Element itself.\n                readyCallback = function readyCallback() {\n                    onReady(element);\n                };\n            }\n        }\n        useAttachEvent(element, \"ready\", readyCallback);\n        var changeCallback = type === \"cart\" ? function(event) {\n            setCartState(event);\n            onChange && onChange(event);\n        } : onChange;\n        useAttachEvent(element, \"change\", changeCallback);\n        var checkoutCallback = type === \"cart\" ? function(event) {\n            setCartState(event);\n            onCheckout && onCheckout(event);\n        } : onCheckout;\n        useAttachEvent(element, \"checkout\", checkoutCallback);\n        react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect(function() {\n            if (elementRef.current === null && elements && domNode.current !== null) {\n                var newElement = elements.create(type, options);\n                if (type === \"cart\" && setCart) {\n                    // we know that elements.create return value must be of type StripeCartElement if type is 'cart',\n                    // we need to cast because typescript is not able to infer which overloaded method is used based off param type\n                    setCart(newElement);\n                } // Store element in a ref to ensure it's _immediately_ available in cleanup hooks in StrictMode\n                elementRef.current = newElement; // Store element in state to facilitate event listener attachment\n                setElement(newElement);\n                newElement.mount(domNode.current);\n            }\n        }, [\n            elements,\n            options,\n            setCart\n        ]);\n        var prevOptions = usePrevious(options);\n        react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n            if (!elementRef.current) {\n                return;\n            }\n            var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n                \"paymentRequest\"\n            ]);\n            if (updates) {\n                elementRef.current.update(updates);\n            }\n        }, [\n            options,\n            prevOptions\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect(function() {\n            return function() {\n                if (elementRef.current) {\n                    elementRef.current.destroy();\n                    elementRef.current = null;\n                }\n            };\n        }, []);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            id: id,\n            className: className,\n            ref: domNode\n        });\n    }; // Only render the Element wrapper in a server environment.\n    var ServerElement = function ServerElement(props) {\n        // Validate that we are in the right context by calling useElementsContextWithUseCase.\n        useElementsContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        useCartElementContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        var id = props.id, className = props.className;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            id: id,\n            className: className\n        });\n    };\n    var Element = isServer ? ServerElement : ClientElement;\n    Element.propTypes = {\n        id: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n        className: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n        onChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onBlur: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onFocus: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onReady: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onEscape: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onClick: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onLoadError: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onLoaderStart: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onNetworksChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onCheckout: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onLineItemClick: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onConfirm: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onCancel: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onShippingAddressChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onShippingRateChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        options: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)\n    };\n    Element.displayName = displayName;\n    Element.__elementType = type;\n    return Element;\n};\nvar isServer = \"undefined\" === \"undefined\";\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AuBankAccountElement = createElementComponent(\"auBankAccount\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardElement = createElementComponent(\"card\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardNumberElement = createElementComponent(\"cardNumber\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardExpiryElement = createElementComponent(\"cardExpiry\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardCvcElement = createElementComponent(\"cardCvc\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var FpxBankElement = createElementComponent(\"fpxBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IbanElement = createElementComponent(\"iban\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IdealBankElement = createElementComponent(\"idealBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var P24BankElement = createElementComponent(\"p24Bank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var EpsBankElement = createElementComponent(\"epsBank\", isServer);\nvar PaymentElement = createElementComponent(\"payment\", isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PayButtonElement = createElementComponent(\"payButton\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentRequestButtonElement = createElementComponent(\"paymentRequestButton\", isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var LinkAuthenticationElement = createElementComponent(\"linkAuthentication\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AddressElement = createElementComponent(\"address\", isServer);\n/**\n * @deprecated\n * Use `AddressElement` instead.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ShippingAddressElement = createElementComponent(\"shippingAddress\", isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/elements/cart-element\n */ var CartElement = createElementComponent(\"cart\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentMethodMessagingElement = createElementComponent(\"paymentMethodMessaging\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AffirmMessageElement = createElementComponent(\"affirmMessage\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AfterpayClearpayMessageElement = createElementComponent(\"afterpayClearpayMessage\", isServer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUNTO0FBRW5DLFNBQVNFLFFBQVFDLE1BQU0sRUFBRUMsY0FBYztJQUNyQyxJQUFJQyxPQUFPQyxPQUFPRCxJQUFJLENBQUNGO0lBRXZCLElBQUlHLE9BQU9DLHFCQUFxQixFQUFFO1FBQ2hDLElBQUlDLFVBQVVGLE9BQU9DLHFCQUFxQixDQUFDSjtRQUUzQyxJQUFJQyxnQkFBZ0I7WUFDbEJJLFVBQVVBLFFBQVFDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHO2dCQUNwQyxPQUFPSixPQUFPSyx3QkFBd0IsQ0FBQ1IsUUFBUU8sS0FBS0UsVUFBVTtZQUNoRTtRQUNGO1FBRUFQLEtBQUtRLElBQUksQ0FBQ0MsS0FBSyxDQUFDVCxNQUFNRztJQUN4QjtJQUVBLE9BQU9IO0FBQ1Q7QUFFQSxTQUFTVSxlQUFlQyxNQUFNO0lBQzVCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7UUFDekMsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFLElBQUksT0FBT0MsU0FBUyxDQUFDRCxFQUFFLEdBQUcsQ0FBQztRQUVwRCxJQUFJQSxJQUFJLEdBQUc7WUFDVGYsUUFBUUksT0FBT2MsU0FBUyxNQUFNQyxPQUFPLENBQUMsU0FBVUMsR0FBRztnQkFDakRDLGdCQUFnQlAsUUFBUU0sS0FBS0YsTUFBTSxDQUFDRSxJQUFJO1lBQzFDO1FBQ0YsT0FBTyxJQUFJaEIsT0FBT2tCLHlCQUF5QixFQUFFO1lBQzNDbEIsT0FBT21CLGdCQUFnQixDQUFDVCxRQUFRVixPQUFPa0IseUJBQXlCLENBQUNKO1FBQ25FLE9BQU87WUFDTGxCLFFBQVFJLE9BQU9jLFNBQVNDLE9BQU8sQ0FBQyxTQUFVQyxHQUFHO2dCQUMzQ2hCLE9BQU9vQixj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LHVCQUF1QixjQUFjRTtBQUM3RDs7Q0FFQyxHQUVELElBQUl1QyxvQkFBb0J6Qyx1QkFBdUIsY0FBY0U7QUFDN0Q7O0NBRUMsR0FFRCxJQUFJd0MsaUJBQWlCMUMsdUJBQXVCLFdBQVdFO0FBQ3ZEOztDQUVDLEdBRUQsSUFBSXlDLGlCQUFpQjNDLHVCQUF1QixXQUFXRTtBQUN2RDs7Q0FFQyxHQUVELElBQUkwQyxjQUFjNUMsdUJBQXVCLFFBQVFFO0FBQ2pEOztDQUVDLEdBRUQsSUFBSTJDLG1CQUFtQjdDLHVCQUF1QixhQUFhRTtBQUMzRDs7Q0FFQyxHQUVELElBQUk0QyxpQkFBaUI5Qyx1QkFBdUIsV0FBV0U7QUFDdkQ7O0NBRUMsR0FFRCxJQUFJNkMsaUJBQWlCL0MsdUJBQXVCLFdBQVdFO0FBQ3ZELElBQUk4QyxpQkFBaUJoRCx1QkFBdUIsV0FBV0U7QUFDdkQ7Ozs7O0NBS0MsR0FFRCxJQUFJK0MsbUJBQW1CakQsdUJBQXVCLGFBQWFFO0FBQzNEOztDQUVDLEdBRUQsSUFBSWdELDhCQUE4QmxELHVCQUF1Qix3QkFBd0JFO0FBQ2pGOzs7OztDQUtDLEdBRUQsSUFBSWlELDRCQUE0Qm5ELHVCQUF1QixzQkFBc0JFO0FBQzdFOztDQUVDLEdBRUQsSUFBSWtELGlCQUFpQnBELHVCQUF1QixXQUFXRTtBQUN2RDs7Ozs7Q0FLQyxHQUVELElBQUltRCx5QkFBeUJyRCx1QkFBdUIsbUJBQW1CRTtBQUN2RTs7Ozs7Q0FLQyxHQUVELElBQUlvRCxjQUFjdEQsdUJBQXVCLFFBQVFFO0FBQ2pEOztDQUVDLEdBRUQsSUFBSXFELGdDQUFnQ3ZELHVCQUF1QiwwQkFBMEJFO0FBQ3JGOztDQUVDLEdBRUQsSUFBSXNELHVCQUF1QnhELHVCQUF1QixpQkFBaUJFO0FBQ25FOztDQUVDLEdBRUQsSUFBSXVELGlDQUFpQ3pELHVCQUF1QiwyQkFBMkJFO0FBRXdaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFuZGluZ3BhZ2UvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLmpzP2I1ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcblxuICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciAmJiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdKTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgdXNlUHJldmlvdXMgPSBmdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICB2YXIgcmVmID0gUmVhY3QudXNlUmVmKHZhbHVlKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufTtcblxudmFyIGlzVW5rbm93bk9iamVjdCA9IGZ1bmN0aW9uIGlzVW5rbm93bk9iamVjdChyYXcpIHtcbiAgcmV0dXJuIHJhdyAhPT0gbnVsbCAmJiBfdHlwZW9mKHJhdykgPT09ICdvYmplY3QnO1xufTtcbnZhciBpc1Byb21pc2UgPSBmdW5jdGlvbiBpc1Byb21pc2UocmF3KSB7XG4gIHJldHVybiBpc1Vua25vd25PYmplY3QocmF3KSAmJiB0eXBlb2YgcmF3LnRoZW4gPT09ICdmdW5jdGlvbic7XG59OyAvLyBXZSBhcmUgdXNpbmcgdHlwZXMgdG8gZW5mb3JjZSB0aGUgYHN0cmlwZWAgcHJvcCBpbiB0aGlzIGxpYixcbi8vIGJ1dCBpbiBhbiB1bnR5cGVkIGludGVncmF0aW9uIGBzdHJpcGVgIGNvdWxkIGJlIGFueXRoaW5nLCBzbyB3ZSBuZWVkXG4vLyB0byBkbyBzb21lIHNhbml0eSB2YWxpZGF0aW9uIHRvIHByZXZlbnQgdHlwZSBlcnJvcnMuXG5cbnZhciBpc1N0cmlwZSA9IGZ1bmN0aW9uIGlzU3RyaXBlKHJhdykge1xuICByZXR1cm4gaXNVbmtub3duT2JqZWN0KHJhdykgJiYgdHlwZW9mIHJhdy5lbGVtZW50cyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNyZWF0ZVRva2VuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByYXcuY3JlYXRlUGF5bWVudE1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNvbmZpcm1DYXJkUGF5bWVudCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBQTEFJTl9PQkpFQ1RfU1RSID0gJ1tvYmplY3QgT2JqZWN0XSc7XG52YXIgaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgaWYgKCFpc1Vua25vd25PYmplY3QobGVmdCkgfHwgIWlzVW5rbm93bk9iamVjdChyaWdodCkpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIH1cblxuICB2YXIgbGVmdEFycmF5ID0gQXJyYXkuaXNBcnJheShsZWZ0KTtcbiAgdmFyIHJpZ2h0QXJyYXkgPSBBcnJheS5pc0FycmF5KHJpZ2h0KTtcbiAgaWYgKGxlZnRBcnJheSAhPT0gcmlnaHRBcnJheSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgbGVmdFBsYWluT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGxlZnQpID09PSBQTEFJTl9PQkpFQ1RfU1RSO1xuICB2YXIgcmlnaHRQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyaWdodCkgPT09IFBMQUlOX09CSkVDVF9TVFI7XG4gIGlmIChsZWZ0UGxhaW5PYmplY3QgIT09IHJpZ2h0UGxhaW5PYmplY3QpIHJldHVybiBmYWxzZTsgLy8gbm90IHN1cmUgd2hhdCBzb3J0IG9mIHNwZWNpYWwgb2JqZWN0IHRoaXMgaXMgKHJlZ2V4cCBpcyBvbmUgb3B0aW9uKSwgc29cbiAgLy8gZmFsbGJhY2sgdG8gcmVmZXJlbmNlIGNoZWNrLlxuXG4gIGlmICghbGVmdFBsYWluT2JqZWN0ICYmICFsZWZ0QXJyYXkpIHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgdmFyIGxlZnRLZXlzID0gT2JqZWN0LmtleXMobGVmdCk7XG4gIHZhciByaWdodEtleXMgPSBPYmplY3Qua2V5cyhyaWdodCk7XG4gIGlmIChsZWZ0S2V5cy5sZW5ndGggIT09IHJpZ2h0S2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtleVNldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBrZXlTZXRbbGVmdEtleXNbaV1dID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCByaWdodEtleXMubGVuZ3RoOyBfaSArPSAxKSB7XG4gICAga2V5U2V0W3JpZ2h0S2V5c1tfaV1dID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBhbGxLZXlzID0gT2JqZWN0LmtleXMoa2V5U2V0KTtcblxuICBpZiAoYWxsS2V5cy5sZW5ndGggIT09IGxlZnRLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsID0gbGVmdDtcbiAgdmFyIHIgPSByaWdodDtcblxuICB2YXIgcHJlZCA9IGZ1bmN0aW9uIHByZWQoa2V5KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobFtrZXldLCByW2tleV0pO1xuICB9O1xuXG4gIHJldHVybiBhbGxLZXlzLmV2ZXJ5KHByZWQpO1xufTtcblxudmFyIGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMgPSBmdW5jdGlvbiBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzKG9wdGlvbnMsIHByZXZPcHRpb25zLCBpbW11dGFibGVLZXlzKSB7XG4gIGlmICghaXNVbmtub3duT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKGZ1bmN0aW9uIChuZXdPcHRpb25zLCBrZXkpIHtcbiAgICB2YXIgaXNVcGRhdGVkID0gIWlzVW5rbm93bk9iamVjdChwcmV2T3B0aW9ucykgfHwgIWlzRXF1YWwob3B0aW9uc1trZXldLCBwcmV2T3B0aW9uc1trZXldKTtcblxuICAgIGlmIChpbW11dGFibGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGlmIChpc1VwZGF0ZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2U6IG9wdGlvbnMuXCIuY29uY2F0KGtleSwgXCIgaXMgbm90IGEgbXV0YWJsZSBwcm9wZXJ0eS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3T3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoIWlzVXBkYXRlZCkge1xuICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBuZXdPcHRpb25zIHx8IHt9KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBvcHRpb25zW2tleV0pKTtcbiAgfSwgbnVsbCk7XG59O1xuXG52YXIgSU5WQUxJRF9TVFJJUEVfRVJST1IgPSAnSW52YWxpZCBwcm9wIGBzdHJpcGVgIHN1cHBsaWVkIHRvIGBFbGVtZW50c2AuIFdlIHJlY29tbWVuZCB1c2luZyB0aGUgYGxvYWRTdHJpcGVgIHV0aWxpdHkgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgLiBTZWUgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3BzLXN0cmlwZSBmb3IgZGV0YWlscy4nOyAvLyBXZSBhcmUgdXNpbmcgdHlwZXMgdG8gZW5mb3JjZSB0aGUgYHN0cmlwZWAgcHJvcCBpbiB0aGlzIGxpYiwgYnV0IGluIGEgcmVhbFxuLy8gaW50ZWdyYXRpb24gYHN0cmlwZWAgY291bGQgYmUgYW55dGhpbmcsIHNvIHdlIG5lZWQgdG8gZG8gc29tZSBzYW5pdHlcbi8vIHZhbGlkYXRpb24gdG8gcHJldmVudCB0eXBlIGVycm9ycy5cblxudmFyIHZhbGlkYXRlU3RyaXBlID0gZnVuY3Rpb24gdmFsaWRhdGVTdHJpcGUobWF5YmVTdHJpcGUpIHtcbiAgaWYgKG1heWJlU3RyaXBlID09PSBudWxsIHx8IGlzU3RyaXBlKG1heWJlU3RyaXBlKSkge1xuICAgIHJldHVybiBtYXliZVN0cmlwZTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1NUUklQRV9FUlJPUik7XG59O1xuXG52YXIgcGFyc2VTdHJpcGVQcm9wID0gZnVuY3Rpb24gcGFyc2VTdHJpcGVQcm9wKHJhdykge1xuICBpZiAoaXNQcm9taXNlKHJhdykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiAnYXN5bmMnLFxuICAgICAgc3RyaXBlUHJvbWlzZTogUHJvbWlzZS5yZXNvbHZlKHJhdykudGhlbih2YWxpZGF0ZVN0cmlwZSlcbiAgICB9O1xuICB9XG5cbiAgdmFyIHN0cmlwZSA9IHZhbGlkYXRlU3RyaXBlKHJhdyk7XG5cbiAgaWYgKHN0cmlwZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6ICdlbXB0eSdcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0YWc6ICdzeW5jJyxcbiAgICBzdHJpcGU6IHN0cmlwZVxuICB9O1xufTtcblxudmFyIEVsZW1lbnRzQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRWxlbWVudHNDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0VsZW1lbnRzQ29udGV4dCc7XG52YXIgcGFyc2VFbGVtZW50c0NvbnRleHQgPSBmdW5jdGlvbiBwYXJzZUVsZW1lbnRzQ29udGV4dChjdHgsIHVzZUNhc2UpIHtcbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBFbGVtZW50cyBjb250ZXh0OyBZb3UgbmVlZCB0byB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgXCIuY29uY2F0KHVzZUNhc2UsIFwiIGluIGFuIDxFbGVtZW50cz4gcHJvdmlkZXIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xudmFyIENhcnRFbGVtZW50Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuQ2FydEVsZW1lbnRDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0NhcnRFbGVtZW50Q29udGV4dCc7XG52YXIgcGFyc2VDYXJ0RWxlbWVudENvbnRleHQgPSBmdW5jdGlvbiBwYXJzZUNhcnRFbGVtZW50Q29udGV4dChjdHgsIHVzZUNhc2UpIHtcbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBFbGVtZW50cyBjb250ZXh0OyBZb3UgbmVlZCB0byB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgXCIuY29uY2F0KHVzZUNhc2UsIFwiIGluIGFuIDxFbGVtZW50cz4gcHJvdmlkZXIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xuLyoqXG4gKiBUaGUgYEVsZW1lbnRzYCBwcm92aWRlciBhbGxvd3MgeW91IHRvIHVzZSBbRWxlbWVudCBjb21wb25lbnRzXShodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzKSBhbmQgYWNjZXNzIHRoZSBbU3RyaXBlIG9iamVjdF0oaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3MvanMvaW5pdGlhbGl6aW5nKSBpbiBhbnkgbmVzdGVkIGNvbXBvbmVudC5cbiAqIFJlbmRlciBhbiBgRWxlbWVudHNgIHByb3ZpZGVyIGF0IHRoZSByb290IG9mIHlvdXIgUmVhY3QgYXBwIHNvIHRoYXQgaXQgaXMgYXZhaWxhYmxlIGV2ZXJ5d2hlcmUgeW91IG5lZWQgaXQuXG4gKlxuICogVG8gdXNlIHRoZSBgRWxlbWVudHNgIHByb3ZpZGVyLCBjYWxsIGBsb2FkU3RyaXBlYCBmcm9tIGBAc3RyaXBlL3N0cmlwZS1qc2Agd2l0aCB5b3VyIHB1Ymxpc2hhYmxlIGtleS5cbiAqIFRoZSBgbG9hZFN0cmlwZWAgZnVuY3Rpb24gd2lsbCBhc3luY2hyb25vdXNseSBsb2FkIHRoZSBTdHJpcGUuanMgc2NyaXB0IGFuZCBpbml0aWFsaXplIGEgYFN0cmlwZWAgb2JqZWN0LlxuICogUGFzcyB0aGUgcmV0dXJuZWQgYFByb21pc2VgIHRvIGBFbGVtZW50c2AuXG4gKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3ZpZGVyXG4gKi9cblxudmFyIEVsZW1lbnRzID0gZnVuY3Rpb24gRWxlbWVudHMoX3JlZikge1xuICB2YXIgcmF3U3RyaXBlUHJvcCA9IF9yZWYuc3RyaXBlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIHBhcnNlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXJzZVN0cmlwZVByb3AocmF3U3RyaXBlUHJvcCk7XG4gIH0sIFtyYXdTdHJpcGVQcm9wXSk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBjYXJ0ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldENhcnQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICBfUmVhY3QkdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlMywgMiksXG4gICAgICBjYXJ0U3RhdGUgPSBfUmVhY3QkdXNlU3RhdGU0WzBdLFxuICAgICAgc2V0Q2FydFN0YXRlID0gX1JlYWN0JHVzZVN0YXRlNFsxXTsgLy8gRm9yIGEgc3luYyBzdHJpcGUgaW5zdGFuY2UsIGluaXRpYWxpemUgaW50byBjb250ZXh0XG5cblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlNSA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyaXBlOiBwYXJzZWQudGFnID09PSAnc3luYycgPyBwYXJzZWQuc3RyaXBlIDogbnVsbCxcbiAgICAgIGVsZW1lbnRzOiBwYXJzZWQudGFnID09PSAnc3luYycgPyBwYXJzZWQuc3RyaXBlLmVsZW1lbnRzKG9wdGlvbnMpIDogbnVsbFxuICAgIH07XG4gIH0pLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlNiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZTUsIDIpLFxuICAgICAgY3R4ID0gX1JlYWN0JHVzZVN0YXRlNlswXSxcbiAgICAgIHNldENvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGU2WzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlzTW91bnRlZCA9IHRydWU7XG5cbiAgICB2YXIgc2FmZVNldENvbnRleHQgPSBmdW5jdGlvbiBzYWZlU2V0Q29udGV4dChzdHJpcGUpIHtcbiAgICAgIHNldENvbnRleHQoZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAvLyBuby1vcCBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdHJpcGUgaW5zdGFuY2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9zdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL2lzc3Vlcy8yOTYpXG4gICAgICAgIGlmIChjdHguc3RyaXBlKSByZXR1cm4gY3R4O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cmlwZTogc3RyaXBlLFxuICAgICAgICAgIGVsZW1lbnRzOiBzdHJpcGUuZWxlbWVudHMob3B0aW9ucylcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07IC8vIEZvciBhbiBhc3luYyBzdHJpcGVQcm9taXNlLCBzdG9yZSBpdCBpbiBjb250ZXh0IG9uY2UgcmVzb2x2ZWRcblxuXG4gICAgaWYgKHBhcnNlZC50YWcgPT09ICdhc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN0cmlwZSkge1xuICAgICAgICBpZiAoc3RyaXBlICYmIGlzTW91bnRlZCkge1xuICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIEVsZW1lbnRzIGNvbnRleHQgaWYgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkXG4gICAgICAgICAgLy8gYW5kIHN0cmlwZSBpcyBub3QgbnVsbC4gV2UgYWxsb3cgc3RyaXBlIHRvIGJlIG51bGwgdG8gbWFrZVxuICAgICAgICAgIC8vIGhhbmRsaW5nIFNTUiBlYXNpZXIuXG4gICAgICAgICAgc2FmZVNldENvbnRleHQoc3RyaXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWQudGFnID09PSAnc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIC8vIE9yLCBoYW5kbGUgYSBzeW5jIHN0cmlwZSBpbnN0YW5jZSBnb2luZyBmcm9tIG51bGwgLT4gcG9wdWxhdGVkXG4gICAgICBzYWZlU2V0Q29udGV4dChwYXJzZWQuc3RyaXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW3BhcnNlZCwgY3R4LCBvcHRpb25zXSk7IC8vIFdhcm4gb24gY2hhbmdlcyB0byBzdHJpcGUgcHJvcFxuXG4gIHZhciBwcmV2U3RyaXBlID0gdXNlUHJldmlvdXMocmF3U3RyaXBlUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZTdHJpcGUgIT09IG51bGwgJiYgcHJldlN0cmlwZSAhPT0gcmF3U3RyaXBlUHJvcCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbGVtZW50czogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIGBzdHJpcGVgIHByb3AgYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG4gIH0sIFtwcmV2U3RyaXBlLCByYXdTdHJpcGVQcm9wXSk7IC8vIEFwcGx5IHVwZGF0ZXMgdG8gZWxlbWVudHMgd2hlbiBvcHRpb25zIHByb3AgaGFzIHJlbGV2YW50IGNoYW5nZXNcblxuICB2YXIgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWN0eC5lbGVtZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVzID0gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgWydjbGllbnRTZWNyZXQnLCAnZm9udHMnXSk7XG5cbiAgICBpZiAodXBkYXRlcykge1xuICAgICAgY3R4LmVsZW1lbnRzLnVwZGF0ZSh1cGRhdGVzKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCBwcmV2T3B0aW9ucywgY3R4LmVsZW1lbnRzXSk7IC8vIEF0dGFjaCByZWFjdC1zdHJpcGUtanMgdmVyc2lvbiB0byBzdHJpcGUuanMgaW5zdGFuY2VcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhbnlTdHJpcGUgPSBjdHguc3RyaXBlO1xuXG4gICAgaWYgKCFhbnlTdHJpcGUgfHwgIWFueVN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyIHx8ICFhbnlTdHJpcGUucmVnaXN0ZXJBcHBJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYW55U3RyaXBlLl9yZWdpc3RlcldyYXBwZXIoe1xuICAgICAgbmFtZTogJ3JlYWN0LXN0cmlwZS1qcycsXG4gICAgICB2ZXJzaW9uOiBcIjEuMTYuNVwiXG4gICAgfSk7XG5cbiAgICBhbnlTdHJpcGUucmVnaXN0ZXJBcHBJbmZvKHtcbiAgICAgIG5hbWU6ICdyZWFjdC1zdHJpcGUtanMnLFxuICAgICAgdmVyc2lvbjogXCIxLjE2LjVcIixcbiAgICAgIHVybDogJ2h0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCdcbiAgICB9KTtcbiAgfSwgW2N0eC5zdHJpcGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVsZW1lbnRzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjdHhcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FydEVsZW1lbnRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIGNhcnQ6IGNhcnQsXG4gICAgICBzZXRDYXJ0OiBzZXRDYXJ0LFxuICAgICAgY2FydFN0YXRlOiBjYXJ0U3RhdGUsXG4gICAgICBzZXRDYXJ0U3RhdGU6IHNldENhcnRTdGF0ZVxuICAgIH1cbiAgfSwgY2hpbGRyZW4pKTtcbn07XG5FbGVtZW50cy5wcm9wVHlwZXMgPSB7XG4gIHN0cmlwZTogUHJvcFR5cGVzLmFueSxcbiAgb3B0aW9uczogUHJvcFR5cGVzLm9iamVjdFxufTtcbnZhciB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSA9IGZ1bmN0aW9uIHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlKHVzZUNhc2VNZXNzYWdlKSB7XG4gIHZhciBjdHggPSBSZWFjdC51c2VDb250ZXh0KEVsZW1lbnRzQ29udGV4dCk7XG4gIHJldHVybiBwYXJzZUVsZW1lbnRzQ29udGV4dChjdHgsIHVzZUNhc2VNZXNzYWdlKTtcbn07XG52YXIgdXNlQ2FydEVsZW1lbnRDb250ZXh0V2l0aFVzZUNhc2UgPSBmdW5jdGlvbiB1c2VDYXJ0RWxlbWVudENvbnRleHRXaXRoVXNlQ2FzZSh1c2VDYXNlTWVzc2FnZSkge1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChDYXJ0RWxlbWVudENvbnRleHQpO1xuICByZXR1cm4gcGFyc2VDYXJ0RWxlbWVudENvbnRleHQoY3R4LCB1c2VDYXNlTWVzc2FnZSk7XG59O1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjdXNlZWxlbWVudHMtaG9va1xuICovXG5cbnZhciB1c2VFbGVtZW50cyA9IGZ1bmN0aW9uIHVzZUVsZW1lbnRzKCkge1xuICB2YXIgX3VzZUVsZW1lbnRzQ29udGV4dFdpID0gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZUVsZW1lbnRzKCknKSxcbiAgICAgIGVsZW1lbnRzID0gX3VzZUVsZW1lbnRzQ29udGV4dFdpLmVsZW1lbnRzO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn07XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCN1c2VzdHJpcGUtaG9va1xuICovXG5cbnZhciB1c2VTdHJpcGUgPSBmdW5jdGlvbiB1c2VTdHJpcGUoKSB7XG4gIHZhciBfdXNlRWxlbWVudHNDb250ZXh0V2kyID0gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZVN0cmlwZSgpJyksXG4gICAgICBzdHJpcGUgPSBfdXNlRWxlbWVudHNDb250ZXh0V2kyLnN0cmlwZTtcblxuICByZXR1cm4gc3RyaXBlO1xufTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3MvcGF5bWVudHMvY2hlY2tvdXQvY2FydC1lbGVtZW50XG4gKi9cblxudmFyIHVzZUNhcnRFbGVtZW50ID0gZnVuY3Rpb24gdXNlQ2FydEVsZW1lbnQoKSB7XG4gIHZhciBfdXNlQ2FydEVsZW1lbnRDb250ZXggPSB1c2VDYXJ0RWxlbWVudENvbnRleHRXaXRoVXNlQ2FzZSgnY2FsbHMgdXNlQ2FydEVsZW1lbnQoKScpLFxuICAgICAgY2FydCA9IF91c2VDYXJ0RWxlbWVudENvbnRleC5jYXJ0O1xuXG4gIHJldHVybiBjYXJ0O1xufTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3MvcGF5bWVudHMvY2hlY2tvdXQvY2FydC1lbGVtZW50XG4gKi9cblxudmFyIHVzZUNhcnRFbGVtZW50U3RhdGUgPSBmdW5jdGlvbiB1c2VDYXJ0RWxlbWVudFN0YXRlKCkge1xuICB2YXIgX3VzZUNhcnRFbGVtZW50Q29udGV4MiA9IHVzZUNhcnRFbGVtZW50Q29udGV4dFdpdGhVc2VDYXNlKCdjYWxscyB1c2VDYXJ0RWxlbWVudFN0YXRlKCknKSxcbiAgICAgIGNhcnRTdGF0ZSA9IF91c2VDYXJ0RWxlbWVudENvbnRleDIuY2FydFN0YXRlO1xuXG4gIHJldHVybiBjYXJ0U3RhdGU7XG59O1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudHMtY29uc3VtZXJcbiAqL1xuXG52YXIgRWxlbWVudHNDb25zdW1lciA9IGZ1bmN0aW9uIEVsZW1lbnRzQ29uc3VtZXIoX3JlZjIpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZjIuY2hpbGRyZW47XG4gIHZhciBjdHggPSB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSgnbW91bnRzIDxFbGVtZW50c0NvbnN1bWVyPicpOyAvLyBBc3NlcnQgdG8gc2F0aXNmeSB0aGUgYnVzdGVkIFJlYWN0LkZDIHJldHVybiB0eXBlIChpdCBzaG91bGQgYmUgUmVhY3ROb2RlKVxuXG4gIHJldHVybiBjaGlsZHJlbihjdHgpO1xufTtcbkVsZW1lbnRzQ29uc3VtZXIucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufTtcblxudmFyIHVzZUF0dGFjaEV2ZW50ID0gZnVuY3Rpb24gdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgZXZlbnQsIGNiKSB7XG4gIHZhciBjYkRlZmluZWQgPSAhIWNiO1xuICB2YXIgY2JSZWYgPSBSZWFjdC51c2VSZWYoY2IpOyAvLyBJbiBtYW55IGludGVncmF0aW9ucyB0aGUgY2FsbGJhY2sgcHJvcCBjaGFuZ2VzIG9uIGVhY2ggcmVuZGVyLlxuICAvLyBVc2luZyBhIHJlZiBzYXZlcyB1cyBmcm9tIGNhbGxpbmcgZWxlbWVudC5vbi8ub2ZmIGV2ZXJ5IHJlbmRlci5cblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGNiUmVmLmN1cnJlbnQgPSBjYjtcbiAgfSwgW2NiXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYkRlZmluZWQgfHwgIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG5cbiAgICB2YXIgZGVjb3JhdGVkQ2IgPSBmdW5jdGlvbiBkZWNvcmF0ZWRDYigpIHtcbiAgICAgIGlmIChjYlJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNiUmVmLmN1cnJlbnQuYXBwbHkoY2JSZWYsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsZW1lbnQub24oZXZlbnQsIGRlY29yYXRlZENiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZWxlbWVudC5vZmYoZXZlbnQsIGRlY29yYXRlZENiKTtcbiAgICB9O1xuICB9LCBbY2JEZWZpbmVkLCBldmVudCwgZWxlbWVudCwgY2JSZWZdKTtcbn07XG5cbnZhciBjYXBpdGFsaXplZCA9IGZ1bmN0aW9uIGNhcGl0YWxpemVkKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcblxudmFyIGNyZWF0ZUVsZW1lbnRDb21wb25lbnQgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50Q29tcG9uZW50KHR5cGUsIGlzU2VydmVyKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IFwiXCIuY29uY2F0KGNhcGl0YWxpemVkKHR5cGUpLCBcIkVsZW1lbnRcIik7XG5cbiAgdmFyIENsaWVudEVsZW1lbnQgPSBmdW5jdGlvbiBDbGllbnRFbGVtZW50KF9yZWYpIHtcbiAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgICAgX3JlZiRvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgb25CbHVyID0gX3JlZi5vbkJsdXIsXG4gICAgICAgIG9uRm9jdXMgPSBfcmVmLm9uRm9jdXMsXG4gICAgICAgIG9uUmVhZHkgPSBfcmVmLm9uUmVhZHksXG4gICAgICAgIG9uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZSxcbiAgICAgICAgb25Fc2NhcGUgPSBfcmVmLm9uRXNjYXBlLFxuICAgICAgICBvbkNsaWNrID0gX3JlZi5vbkNsaWNrLFxuICAgICAgICBvbkxvYWRFcnJvciA9IF9yZWYub25Mb2FkRXJyb3IsXG4gICAgICAgIG9uTG9hZGVyU3RhcnQgPSBfcmVmLm9uTG9hZGVyU3RhcnQsXG4gICAgICAgIG9uTmV0d29ya3NDaGFuZ2UgPSBfcmVmLm9uTmV0d29ya3NDaGFuZ2UsXG4gICAgICAgIG9uQ2hlY2tvdXQgPSBfcmVmLm9uQ2hlY2tvdXQsXG4gICAgICAgIG9uTGluZUl0ZW1DbGljayA9IF9yZWYub25MaW5lSXRlbUNsaWNrLFxuICAgICAgICBvbkNvbmZpcm0gPSBfcmVmLm9uQ29uZmlybSxcbiAgICAgICAgb25DYW5jZWwgPSBfcmVmLm9uQ2FuY2VsLFxuICAgICAgICBvblNoaXBwaW5nQWRkcmVzc0NoYW5nZSA9IF9yZWYub25TaGlwcGluZ0FkZHJlc3NDaGFuZ2UsXG4gICAgICAgIG9uU2hpcHBpbmdSYXRlQ2hhbmdlID0gX3JlZi5vblNoaXBwaW5nUmF0ZUNoYW5nZTtcblxuICAgIHZhciBfdXNlRWxlbWVudHNDb250ZXh0V2kgPSB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZShcIm1vdW50cyA8XCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIj5cIikpLFxuICAgICAgICBlbGVtZW50cyA9IF91c2VFbGVtZW50c0NvbnRleHRXaS5lbGVtZW50cztcblxuICAgIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShudWxsKSxcbiAgICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICAgIGVsZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgICBzZXRFbGVtZW50ID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICAgIHZhciBlbGVtZW50UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBkb21Ob2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gICAgdmFyIF91c2VDYXJ0RWxlbWVudENvbnRleCA9IHVzZUNhcnRFbGVtZW50Q29udGV4dFdpdGhVc2VDYXNlKFwibW91bnRzIDxcIi5jb25jYXQoZGlzcGxheU5hbWUsIFwiPlwiKSksXG4gICAgICAgIHNldENhcnQgPSBfdXNlQ2FydEVsZW1lbnRDb250ZXguc2V0Q2FydCxcbiAgICAgICAgc2V0Q2FydFN0YXRlID0gX3VzZUNhcnRFbGVtZW50Q29udGV4LnNldENhcnRTdGF0ZTsgLy8gRm9yIGV2ZXJ5IGV2ZW50IHdoZXJlIHRoZSBtZXJjaGFudCBwcm92aWRlcyBhIGNhbGxiYWNrLCBjYWxsIGVsZW1lbnQub25cbiAgICAvLyB3aXRoIHRoYXQgY2FsbGJhY2suIElmIHRoZSBtZXJjaGFudCBldmVyIGNoYW5nZXMgdGhlIGNhbGxiYWNrLCByZW1vdmVzXG4gICAgLy8gdGhlIG9sZCBjYWxsYmFjayB3aXRoIGVsZW1lbnQub2ZmIGFuZCB0aGVuIGNhbGwgZWxlbWVudC5vbiB3aXRoIHRoZSBuZXcgb25lLlxuXG5cbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnYmx1cicsIG9uQmx1cik7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2ZvY3VzJywgb25Gb2N1cyk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2VzY2FwZScsIG9uRXNjYXBlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2xpY2snLCBvbkNsaWNrKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnbG9hZGVycm9yJywgb25Mb2FkRXJyb3IpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdsb2FkZXJzdGFydCcsIG9uTG9hZGVyU3RhcnQpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICduZXR3b3Jrc2NoYW5nZScsIG9uTmV0d29ya3NDaGFuZ2UpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdsaW5laXRlbWNsaWNrJywgb25MaW5lSXRlbUNsaWNrKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY29uZmlybScsIG9uQ29uZmlybSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2NhbmNlbCcsIG9uQ2FuY2VsKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnc2hpcHBpbmdhZGRyZXNzY2hhbmdlJywgb25TaGlwcGluZ0FkZHJlc3NDaGFuZ2UpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdzaGlwcGluZ3JhdGVjaGFuZ2UnLCBvblNoaXBwaW5nUmF0ZUNoYW5nZSk7XG4gICAgdmFyIHJlYWR5Q2FsbGJhY2s7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2NhcnQnKSB7XG4gICAgICByZWFkeUNhbGxiYWNrID0gZnVuY3Rpb24gcmVhZHlDYWxsYmFjayhldmVudCkge1xuICAgICAgICBzZXRDYXJ0U3RhdGUoZXZlbnQpO1xuICAgICAgICBvblJlYWR5ICYmIG9uUmVhZHkoZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9uUmVhZHkpIHtcbiAgICAgIGlmICh0eXBlID09PSAncGF5QnV0dG9uJykge1xuICAgICAgICAvLyBQYXNzZXMgdGhyb3VnaCB0aGUgZXZlbnQsIHdoaWNoIGluY2x1ZGVzIHZpc2libGUgUE0gdHlwZXNcbiAgICAgICAgcmVhZHlDYWxsYmFjayA9IG9uUmVhZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb3RoZXIgRWxlbWVudHMsIHBhc3MgdGhyb3VnaCB0aGUgRWxlbWVudCBpdHNlbGYuXG4gICAgICAgIHJlYWR5Q2FsbGJhY2sgPSBmdW5jdGlvbiByZWFkeUNhbGxiYWNrKCkge1xuICAgICAgICAgIG9uUmVhZHkoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3JlYWR5JywgcmVhZHlDYWxsYmFjayk7XG4gICAgdmFyIGNoYW5nZUNhbGxiYWNrID0gdHlwZSA9PT0gJ2NhcnQnID8gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBzZXRDYXJ0U3RhdGUoZXZlbnQpO1xuICAgICAgb25DaGFuZ2UgJiYgb25DaGFuZ2UoZXZlbnQpO1xuICAgIH0gOiBvbkNoYW5nZTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2hhbmdlJywgY2hhbmdlQ2FsbGJhY2spO1xuICAgIHZhciBjaGVja291dENhbGxiYWNrID0gdHlwZSA9PT0gJ2NhcnQnID8gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBzZXRDYXJ0U3RhdGUoZXZlbnQpO1xuICAgICAgb25DaGVja291dCAmJiBvbkNoZWNrb3V0KGV2ZW50KTtcbiAgICB9IDogb25DaGVja291dDtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2hlY2tvdXQnLCBjaGVja291dENhbGxiYWNrKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCA9PT0gbnVsbCAmJiBlbGVtZW50cyAmJiBkb21Ob2RlLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG5ld0VsZW1lbnQgPSBlbGVtZW50cy5jcmVhdGUodHlwZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjYXJ0JyAmJiBzZXRDYXJ0KSB7XG4gICAgICAgICAgLy8gd2Uga25vdyB0aGF0IGVsZW1lbnRzLmNyZWF0ZSByZXR1cm4gdmFsdWUgbXVzdCBiZSBvZiB0eXBlIFN0cmlwZUNhcnRFbGVtZW50IGlmIHR5cGUgaXMgJ2NhcnQnLFxuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2FzdCBiZWNhdXNlIHR5cGVzY3JpcHQgaXMgbm90IGFibGUgdG8gaW5mZXIgd2hpY2ggb3ZlcmxvYWRlZCBtZXRob2QgaXMgdXNlZCBiYXNlZCBvZmYgcGFyYW0gdHlwZVxuICAgICAgICAgIHNldENhcnQobmV3RWxlbWVudCk7XG4gICAgICAgIH0gLy8gU3RvcmUgZWxlbWVudCBpbiBhIHJlZiB0byBlbnN1cmUgaXQncyBfaW1tZWRpYXRlbHlfIGF2YWlsYWJsZSBpbiBjbGVhbnVwIGhvb2tzIGluIFN0cmljdE1vZGVcblxuXG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IG5ld0VsZW1lbnQ7IC8vIFN0b3JlIGVsZW1lbnQgaW4gc3RhdGUgdG8gZmFjaWxpdGF0ZSBldmVudCBsaXN0ZW5lciBhdHRhY2htZW50XG5cbiAgICAgICAgc2V0RWxlbWVudChuZXdFbGVtZW50KTtcbiAgICAgICAgbmV3RWxlbWVudC5tb3VudChkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0sIFtlbGVtZW50cywgb3B0aW9ucywgc2V0Q2FydF0pO1xuICAgIHZhciBwcmV2T3B0aW9ucyA9IHVzZVByZXZpb3VzKG9wdGlvbnMpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVzID0gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgWydwYXltZW50UmVxdWVzdCddKTtcblxuICAgICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50LnVwZGF0ZSh1cGRhdGVzKTtcbiAgICAgIH1cbiAgICB9LCBbb3B0aW9ucywgcHJldk9wdGlvbnNdKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudC5kZXN0cm95KCk7XG4gICAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgcmVmOiBkb21Ob2RlXG4gICAgfSk7XG4gIH07IC8vIE9ubHkgcmVuZGVyIHRoZSBFbGVtZW50IHdyYXBwZXIgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG5cblxuICB2YXIgU2VydmVyRWxlbWVudCA9IGZ1bmN0aW9uIFNlcnZlckVsZW1lbnQocHJvcHMpIHtcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IHdlIGFyZSBpbiB0aGUgcmlnaHQgY29udGV4dCBieSBjYWxsaW5nIHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlLlxuICAgIHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlKFwibW91bnRzIDxcIi5jb25jYXQoZGlzcGxheU5hbWUsIFwiPlwiKSk7XG4gICAgdXNlQ2FydEVsZW1lbnRDb250ZXh0V2l0aFVzZUNhc2UoXCJtb3VudHMgPFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCI+XCIpKTtcbiAgICB2YXIgaWQgPSBwcm9wcy5pZCxcbiAgICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBFbGVtZW50ID0gaXNTZXJ2ZXIgPyBTZXJ2ZXJFbGVtZW50IDogQ2xpZW50RWxlbWVudDtcbiAgRWxlbWVudC5wcm9wVHlwZXMgPSB7XG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVhZHk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRXNjYXBlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxvYWRFcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Mb2FkZXJTdGFydDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25OZXR3b3Jrc0NoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGVja291dDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25MaW5lSXRlbUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNvbmZpcm06IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2FuY2VsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNoaXBwaW5nQWRkcmVzc0NoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TaGlwcGluZ1JhdGVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3RcbiAgfTtcbiAgRWxlbWVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICBFbGVtZW50Ll9fZWxlbWVudFR5cGUgPSB0eXBlO1xuICByZXR1cm4gRWxlbWVudDtcbn07XG5cbnZhciBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBSZXF1aXJlcyBiZXRhIGFjY2VzczpcbiAqIENvbnRhY3QgW1N0cmlwZSBzdXBwb3J0XShodHRwczovL3N1cHBvcnQuc3RyaXBlLmNvbS8pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQXVCYW5rQWNjb3VudEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhdUJhbmtBY2NvdW50JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZCcsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBDYXJkTnVtYmVyRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcmROdW1iZXInLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZEV4cGlyeUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkRXhwaXJ5JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmRDdmNFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZEN2YycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBGcHhCYW5rRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2ZweEJhbmsnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgSWJhbkVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdpYmFuJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIElkZWFsQmFua0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdpZGVhbEJhbmsnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgUDI0QmFua0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdwMjRCYW5rJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEVwc0JhbmtFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnZXBzQmFuaycsIGlzU2VydmVyKTtcbnZhciBQYXltZW50RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3BheW1lbnQnLCBpc1NlcnZlcik7XG4vKipcbiAqIFJlcXVpcmVzIGJldGEgYWNjZXNzOlxuICogQ29udGFjdCBbU3RyaXBlIHN1cHBvcnRdKGh0dHBzOi8vc3VwcG9ydC5zdHJpcGUuY29tLykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBQYXlCdXR0b25FbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncGF5QnV0dG9uJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIFBheW1lbnRSZXF1ZXN0QnV0dG9uRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3BheW1lbnRSZXF1ZXN0QnV0dG9uJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBSZXF1aXJlcyBiZXRhIGFjY2VzczpcbiAqIENvbnRhY3QgW1N0cmlwZSBzdXBwb3J0XShodHRwczovL3N1cHBvcnQuc3RyaXBlLmNvbS8pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2xpbmtBdXRoZW50aWNhdGlvbicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FkZHJlc3MnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBVc2UgYEFkZHJlc3NFbGVtZW50YCBpbnN0ZWFkLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgU2hpcHBpbmdBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3NoaXBwaW5nQWRkcmVzcycsIGlzU2VydmVyKTtcbi8qKlxuICogUmVxdWlyZXMgYmV0YSBhY2Nlc3M6XG4gKiBDb250YWN0IFtTdHJpcGUgc3VwcG9ydF0oaHR0cHM6Ly9zdXBwb3J0LnN0cmlwZS5jb20vKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9lbGVtZW50cy9jYXJ0LWVsZW1lbnRcbiAqL1xuXG52YXIgQ2FydEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJ0JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIFBheW1lbnRNZXRob2RNZXNzYWdpbmdFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncGF5bWVudE1ldGhvZE1lc3NhZ2luZycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBZmZpcm1NZXNzYWdlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FmZmlybU1lc3NhZ2UnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQWZ0ZXJwYXlDbGVhcnBheU1lc3NhZ2VFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnYWZ0ZXJwYXlDbGVhcnBheU1lc3NhZ2UnLCBpc1NlcnZlcik7XG5cbmV4cG9ydCB7IEFkZHJlc3NFbGVtZW50LCBBZmZpcm1NZXNzYWdlRWxlbWVudCwgQWZ0ZXJwYXlDbGVhcnBheU1lc3NhZ2VFbGVtZW50LCBBdUJhbmtBY2NvdW50RWxlbWVudCwgQ2FyZEN2Y0VsZW1lbnQsIENhcmRFbGVtZW50LCBDYXJkRXhwaXJ5RWxlbWVudCwgQ2FyZE51bWJlckVsZW1lbnQsIENhcnRFbGVtZW50LCBFbGVtZW50cywgRWxlbWVudHNDb25zdW1lciwgRXBzQmFua0VsZW1lbnQsIEZweEJhbmtFbGVtZW50LCBJYmFuRWxlbWVudCwgSWRlYWxCYW5rRWxlbWVudCwgTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCwgUDI0QmFua0VsZW1lbnQsIFBheUJ1dHRvbkVsZW1lbnQsIFBheW1lbnRFbGVtZW50LCBQYXltZW50TWV0aG9kTWVzc2FnaW5nRWxlbWVudCwgUGF5bWVudFJlcXVlc3RCdXR0b25FbGVtZW50LCBTaGlwcGluZ0FkZHJlc3NFbGVtZW50LCB1c2VDYXJ0RWxlbWVudCwgdXNlQ2FydEVsZW1lbnRTdGF0ZSwgdXNlRWxlbWVudHMsIHVzZVN0cmlwZSB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiUHJvcFR5cGVzIiwib3duS2V5cyIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsIk9iamVjdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJBcnJheSIsImlzQXJyYXkiLCJfaSIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsImNhbGwiLCJuZXh0IiwiZG9uZSIsImVyciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsIlR5cGVFcnJvciIsInVzZVByZXZpb3VzIiwicmVmIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiY3VycmVudCIsImlzVW5rbm93bk9iamVjdCIsInJhdyIsImlzUHJvbWlzZSIsInRoZW4iLCJpc1N0cmlwZSIsImVsZW1lbnRzIiwiY3JlYXRlVG9rZW4iLCJjcmVhdGVQYXltZW50TWV0aG9kIiwiY29uZmlybUNhcmRQYXltZW50IiwiUExBSU5fT0JKRUNUX1NUUiIsImlzRXF1YWwiLCJsZWZ0IiwicmlnaHQiLCJsZWZ0QXJyYXkiLCJyaWdodEFycmF5IiwibGVmdFBsYWluT2JqZWN0IiwicmlnaHRQbGFpbk9iamVjdCIsImxlZnRLZXlzIiwicmlnaHRLZXlzIiwia2V5U2V0IiwiYWxsS2V5cyIsImwiLCJyIiwicHJlZCIsImV2ZXJ5IiwiZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyIsIm9wdGlvbnMiLCJwcmV2T3B0aW9ucyIsImltbXV0YWJsZUtleXMiLCJyZWR1Y2UiLCJuZXdPcHRpb25zIiwiaXNVcGRhdGVkIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiIsImNvbmNhdCIsIklOVkFMSURfU1RSSVBFX0VSUk9SIiwidmFsaWRhdGVTdHJpcGUiLCJtYXliZVN0cmlwZSIsIkVycm9yIiwicGFyc2VTdHJpcGVQcm9wIiwidGFnIiwic3RyaXBlUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic3RyaXBlIiwiRWxlbWVudHNDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImRpc3BsYXlOYW1lIiwicGFyc2VFbGVtZW50c0NvbnRleHQiLCJjdHgiLCJ1c2VDYXNlIiwiQ2FydEVsZW1lbnRDb250ZXh0IiwicGFyc2VDYXJ0RWxlbWVudENvbnRleHQiLCJFbGVtZW50cyIsIl9yZWYiLCJyYXdTdHJpcGVQcm9wIiwiY2hpbGRyZW4iLCJwYXJzZWQiLCJ1c2VNZW1vIiwiX1JlYWN0JHVzZVN0YXRlIiwidXNlU3RhdGUiLCJfUmVhY3QkdXNlU3RhdGUyIiwiY2FydCIsInNldENhcnQiLCJfUmVhY3QkdXNlU3RhdGUzIiwiX1JlYWN0JHVzZVN0YXRlNCIsImNhcnRTdGF0ZSIsInNldENhcnRTdGF0ZSIsIl9SZWFjdCR1c2VTdGF0ZTUiLCJfUmVhY3QkdXNlU3RhdGU2Iiwic2V0Q29udGV4dCIsImlzTW91bnRlZCIsInNhZmVTZXRDb250ZXh0IiwicHJldlN0cmlwZSIsInVwZGF0ZXMiLCJ1cGRhdGUiLCJhbnlTdHJpcGUiLCJfcmVnaXN0ZXJXcmFwcGVyIiwicmVnaXN0ZXJBcHBJbmZvIiwidmVyc2lvbiIsInVybCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInByb3BUeXBlcyIsImFueSIsInVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlIiwidXNlQ2FzZU1lc3NhZ2UiLCJ1c2VDb250ZXh0IiwidXNlQ2FydEVsZW1lbnRDb250ZXh0V2l0aFVzZUNhc2UiLCJ1c2VFbGVtZW50cyIsIl91c2VFbGVtZW50c0NvbnRleHRXaSIsInVzZVN0cmlwZSIsIl91c2VFbGVtZW50c0NvbnRleHRXaTIiLCJ1c2VDYXJ0RWxlbWVudCIsIl91c2VDYXJ0RWxlbWVudENvbnRleCIsInVzZUNhcnRFbGVtZW50U3RhdGUiLCJfdXNlQ2FydEVsZW1lbnRDb250ZXgyIiwiRWxlbWVudHNDb25zdW1lciIsIl9yZWYyIiwiZnVuYyIsImlzUmVxdWlyZWQiLCJ1c2VBdHRhY2hFdmVudCIsImVsZW1lbnQiLCJldmVudCIsImNiIiwiY2JEZWZpbmVkIiwiY2JSZWYiLCJkZWNvcmF0ZWRDYiIsIm9uIiwib2ZmIiwiY2FwaXRhbGl6ZWQiLCJzdHIiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsImNyZWF0ZUVsZW1lbnRDb21wb25lbnQiLCJ0eXBlIiwiaXNTZXJ2ZXIiLCJDbGllbnRFbGVtZW50IiwiaWQiLCJjbGFzc05hbWUiLCJfcmVmJG9wdGlvbnMiLCJvbkJsdXIiLCJvbkZvY3VzIiwib25SZWFkeSIsIm9uQ2hhbmdlIiwib25Fc2NhcGUiLCJvbkNsaWNrIiwib25Mb2FkRXJyb3IiLCJvbkxvYWRlclN0YXJ0Iiwib25OZXR3b3Jrc0NoYW5nZSIsIm9uQ2hlY2tvdXQiLCJvbkxpbmVJdGVtQ2xpY2siLCJvbkNvbmZpcm0iLCJvbkNhbmNlbCIsIm9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlIiwib25TaGlwcGluZ1JhdGVDaGFuZ2UiLCJzZXRFbGVtZW50IiwiZWxlbWVudFJlZiIsImRvbU5vZGUiLCJyZWFkeUNhbGxiYWNrIiwiY2hhbmdlQ2FsbGJhY2siLCJjaGVja291dENhbGxiYWNrIiwidXNlTGF5b3V0RWZmZWN0IiwibmV3RWxlbWVudCIsImNyZWF0ZSIsIm1vdW50IiwiZGVzdHJveSIsIlNlcnZlckVsZW1lbnQiLCJwcm9wcyIsIkVsZW1lbnQiLCJzdHJpbmciLCJfX2VsZW1lbnRUeXBlIiwiQXVCYW5rQWNjb3VudEVsZW1lbnQiLCJDYXJkRWxlbWVudCIsIkNhcmROdW1iZXJFbGVtZW50IiwiQ2FyZEV4cGlyeUVsZW1lbnQiLCJDYXJkQ3ZjRWxlbWVudCIsIkZweEJhbmtFbGVtZW50IiwiSWJhbkVsZW1lbnQiLCJJZGVhbEJhbmtFbGVtZW50IiwiUDI0QmFua0VsZW1lbnQiLCJFcHNCYW5rRWxlbWVudCIsIlBheW1lbnRFbGVtZW50IiwiUGF5QnV0dG9uRWxlbWVudCIsIlBheW1lbnRSZXF1ZXN0QnV0dG9uRWxlbWVudCIsIkxpbmtBdXRoZW50aWNhdGlvbkVsZW1lbnQiLCJBZGRyZXNzRWxlbWVudCIsIlNoaXBwaW5nQWRkcmVzc0VsZW1lbnQiLCJDYXJ0RWxlbWVudCIsIlBheW1lbnRNZXRob2RNZXNzYWdpbmdFbGVtZW50IiwiQWZmaXJtTWVzc2FnZUVsZW1lbnQiLCJBZnRlcnBheUNsZWFycGF5TWVzc2FnZUVsZW1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js":
/*!*****************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/dist/pure.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nvar V3_URL = \"https://js.stripe.com/v3\";\nvar V3_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/v3\\/?(\\?.*)?$/;\nvar EXISTING_SCRIPT_MESSAGE = \"loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used\";\nvar findScript = function findScript() {\n    var scripts = document.querySelectorAll('script[src^=\"'.concat(V3_URL, '\"]'));\n    for(var i = 0; i < scripts.length; i++){\n        var script = scripts[i];\n        if (!V3_URL_REGEX.test(script.src)) {\n            continue;\n        }\n        return script;\n    }\n    return null;\n};\nvar injectScript = function injectScript(params) {\n    var queryString = params && !params.advancedFraudSignals ? \"?advancedFraudSignals=false\" : \"\";\n    var script = document.createElement(\"script\");\n    script.src = \"\".concat(V3_URL).concat(queryString);\n    var headOrBody = document.head || document.body;\n    if (!headOrBody) {\n        throw new Error(\"Expected document.body not to be null. Stripe.js requires a <body> element.\");\n    }\n    headOrBody.appendChild(script);\n    return script;\n};\nvar registerWrapper = function registerWrapper(stripe, startTime) {\n    if (!stripe || !stripe._registerWrapper) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"stripe-js\",\n        version: \"1.54.2\",\n        startTime: startTime\n    });\n};\nvar stripePromise = null;\nvar loadScript = function loadScript(params) {\n    // Ensure that we only attempt to load Stripe.js at most once\n    if (stripePromise !== null) {\n        return stripePromise;\n    }\n    stripePromise = new Promise(function(resolve, reject) {\n        if (true) {\n            // Resolve to null when imported server side. This makes the module\n            // safe to import in an isomorphic code base.\n            resolve(null);\n            return;\n        }\n        if (window.Stripe && params) {\n            console.warn(EXISTING_SCRIPT_MESSAGE);\n        }\n        if (window.Stripe) {\n            resolve(window.Stripe);\n            return;\n        }\n        try {\n            var script = findScript();\n            if (script && params) {\n                console.warn(EXISTING_SCRIPT_MESSAGE);\n            } else if (!script) {\n                script = injectScript(params);\n            }\n            script.addEventListener(\"load\", function() {\n                if (window.Stripe) {\n                    resolve(window.Stripe);\n                } else {\n                    reject(new Error(\"Stripe.js not available\"));\n                }\n            });\n            script.addEventListener(\"error\", function() {\n                reject(new Error(\"Failed to load Stripe.js\"));\n            });\n        } catch (error) {\n            reject(error);\n            return;\n        }\n    });\n    return stripePromise;\n};\nvar initStripe = function initStripe(maybeStripe, args, startTime) {\n    if (maybeStripe === null) {\n        return null;\n    }\n    var stripe = maybeStripe.apply(undefined, args);\n    registerWrapper(stripe, startTime);\n    return stripe;\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar validateLoadParams = function validateLoadParams(params) {\n    var errorMessage = \"invalid load parameters; expected object of shape\\n\\n    {advancedFraudSignals: boolean}\\n\\nbut received\\n\\n    \".concat(JSON.stringify(params), \"\\n\");\n    if (params === null || _typeof(params) !== \"object\") {\n        throw new Error(errorMessage);\n    }\n    if (Object.keys(params).length === 1 && typeof params.advancedFraudSignals === \"boolean\") {\n        return params;\n    }\n    throw new Error(errorMessage);\n};\nvar loadParams;\nvar loadStripeCalled = false;\nvar loadStripe = function loadStripe() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    loadStripeCalled = true;\n    var startTime = Date.now();\n    return loadScript(loadParams).then(function(maybeStripe) {\n        return initStripe(maybeStripe, args, startTime);\n    });\n};\nloadStripe.setLoadParameters = function(params) {\n    // we won't throw an error if setLoadParameters is called with the same values as before\n    if (loadStripeCalled && loadParams) {\n        var validatedParams = validateLoadParams(params);\n        var parameterKeys = Object.keys(validatedParams);\n        var sameParameters = parameterKeys.reduce(function(previousValue, currentValue) {\n            var _loadParams;\n            return previousValue && params[currentValue] === ((_loadParams = loadParams) === null || _loadParams === void 0 ? void 0 : _loadParams[currentValue]);\n        }, true);\n        if (sameParameters) {\n            return;\n        }\n    }\n    if (loadStripeCalled) {\n        throw new Error(\"You cannot change load parameters after calling loadStripe\");\n    }\n    loadParams = validateLoadParams(params);\n};\nexports.loadStripe = loadStripe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvZGlzdC9wdXJlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELFNBQVNDLFFBQVFDLEdBQUc7SUFDbEI7SUFFQSxJQUFJLE9BQU9DLFdBQVcsY0FBYyxPQUFPQSxPQUFPQyxRQUFRLEtBQUssVUFBVTtRQUN2RUgsVUFBVSxTQUFVQyxHQUFHO1lBQ3JCLE9BQU8sT0FBT0E7UUFDaEI7SUFDRixPQUFPO1FBQ0xELFVBQVUsU0FBVUMsR0FBRztZQUNyQixPQUFPQSxPQUFPLE9BQU9DLFdBQVcsY0FBY0QsSUFBSUcsV0FBVyxLQUFLRixVQUFVRCxRQUFRQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtRQUMzSDtJQUNGO0lBRUEsT0FBT0QsUUFBUUM7QUFDakI7QUFFQSxJQUFJSyxTQUFTO0FBQ2IsSUFBSUMsZUFBZTtBQUNuQixJQUFJQywwQkFBMEI7QUFDOUIsSUFBSUMsYUFBYSxTQUFTQTtJQUN4QixJQUFJQyxVQUFVQyxTQUFTQyxnQkFBZ0IsQ0FBQyxnQkFBaUJDLE1BQU0sQ0FBQ1AsUUFBUTtJQUV4RSxJQUFLLElBQUlRLElBQUksR0FBR0EsSUFBSUosUUFBUUssTUFBTSxFQUFFRCxJQUFLO1FBQ3ZDLElBQUlFLFNBQVNOLE9BQU8sQ0FBQ0ksRUFBRTtRQUV2QixJQUFJLENBQUNQLGFBQWFVLElBQUksQ0FBQ0QsT0FBT0UsR0FBRyxHQUFHO1lBQ2xDO1FBQ0Y7UUFFQSxPQUFPRjtJQUNUO0lBRUEsT0FBTztBQUNUO0FBRUEsSUFBSUcsZUFBZSxTQUFTQSxhQUFhQyxNQUFNO0lBQzdDLElBQUlDLGNBQWNELFVBQVUsQ0FBQ0EsT0FBT0Usb0JBQW9CLEdBQUcsZ0NBQWdDO0lBQzNGLElBQUlOLFNBQVNMLFNBQVNZLGFBQWEsQ0FBQztJQUNwQ1AsT0FBT0UsR0FBRyxHQUFHLEdBQUdMLE1BQU0sQ0FBQ1AsUUFBUU8sTUFB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b0IsWUFBWVMsSUFBSSxDQUFDLFNBQVVsQixXQUFXO1FBQ3RELE9BQU9ELFdBQVdDLGFBQWFDLE1BQU1qQjtJQUN2QztBQUNGO0FBRUEyQixXQUFXUSxpQkFBaUIsR0FBRyxTQUFVOUMsTUFBTTtJQUM3Qyx3RkFBd0Y7SUFDeEYsSUFBSXFDLG9CQUFvQkQsWUFBWTtRQUNsQyxJQUFJVyxrQkFBa0JoQixtQkFBbUIvQjtRQUN6QyxJQUFJZ0QsZ0JBQWdCeEUsT0FBTzJELElBQUksQ0FBQ1k7UUFDaEMsSUFBSUUsaUJBQWlCRCxjQUFjRSxNQUFNLENBQUMsU0FBVUMsYUFBYSxFQUFFQyxZQUFZO1lBQzdFLElBQUlDO1lBRUosT0FBT0YsaUJBQWlCbkQsTUFBTSxDQUFDb0QsYUFBYSxLQUFNLEVBQUNDLGNBQWNqQixVQUFTLE1BQU8sUUFBUWlCLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXLENBQUNELGFBQWE7UUFDdEosR0FBRztRQUVILElBQUlILGdCQUFnQjtZQUNsQjtRQUNGO0lBQ0Y7SUFFQSxJQUFJWixrQkFBa0I7UUFDcEIsTUFBTSxJQUFJOUIsTUFBTTtJQUNsQjtJQUVBNkIsYUFBYUwsbUJBQW1CL0I7QUFDbEM7QUFFQXRCLGtCQUFrQixHQUFHNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYW5kaW5ncGFnZS8uL25vZGVfbW9kdWxlcy9Ac3RyaXBlL3N0cmlwZS1qcy9kaXN0L3B1cmUuanM/OTc1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbnZhciBWM19VUkwgPSAnaHR0cHM6Ly9qcy5zdHJpcGUuY29tL3YzJztcbnZhciBWM19VUkxfUkVHRVggPSAvXmh0dHBzOlxcL1xcL2pzXFwuc3RyaXBlXFwuY29tXFwvdjNcXC8/KFxcPy4qKT8kLztcbnZhciBFWElTVElOR19TQ1JJUFRfTUVTU0FHRSA9ICdsb2FkU3RyaXBlLnNldExvYWRQYXJhbWV0ZXJzIHdhcyBjYWxsZWQgYnV0IGFuIGV4aXN0aW5nIFN0cmlwZS5qcyBzY3JpcHQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGRvY3VtZW50OyBleGlzdGluZyBzY3JpcHQgcGFyYW1ldGVycyB3aWxsIGJlIHVzZWQnO1xudmFyIGZpbmRTY3JpcHQgPSBmdW5jdGlvbiBmaW5kU2NyaXB0KCkge1xuICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzY3JpcHRbc3JjXj1cXFwiXCIuY29uY2F0KFYzX1VSTCwgXCJcXFwiXVwiKSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNjcmlwdCA9IHNjcmlwdHNbaV07XG5cbiAgICBpZiAoIVYzX1VSTF9SRUdFWC50ZXN0KHNjcmlwdC5zcmMpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NyaXB0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgaW5qZWN0U2NyaXB0ID0gZnVuY3Rpb24gaW5qZWN0U2NyaXB0KHBhcmFtcykge1xuICB2YXIgcXVlcnlTdHJpbmcgPSBwYXJhbXMgJiYgIXBhcmFtcy5hZHZhbmNlZEZyYXVkU2lnbmFscyA/ICc/YWR2YW5jZWRGcmF1ZFNpZ25hbHM9ZmFsc2UnIDogJyc7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgc2NyaXB0LnNyYyA9IFwiXCIuY29uY2F0KFYzX1VSTCkuY29uY2F0KHF1ZXJ5U3RyaW5nKTtcbiAgdmFyIGhlYWRPckJvZHkgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgaWYgKCFoZWFkT3JCb2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBkb2N1bWVudC5ib2R5IG5vdCB0byBiZSBudWxsLiBTdHJpcGUuanMgcmVxdWlyZXMgYSA8Ym9keT4gZWxlbWVudC4nKTtcbiAgfVxuXG4gIGhlYWRPckJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgcmV0dXJuIHNjcmlwdDtcbn07XG5cbnZhciByZWdpc3RlcldyYXBwZXIgPSBmdW5jdGlvbiByZWdpc3RlcldyYXBwZXIoc3RyaXBlLCBzdGFydFRpbWUpIHtcbiAgaWYgKCFzdHJpcGUgfHwgIXN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RyaXBlLl9yZWdpc3RlcldyYXBwZXIoe1xuICAgIG5hbWU6ICdzdHJpcGUtanMnLFxuICAgIHZlcnNpb246IFwiMS41NC4yXCIsXG4gICAgc3RhcnRUaW1lOiBzdGFydFRpbWVcbiAgfSk7XG59O1xuXG52YXIgc3RyaXBlUHJvbWlzZSA9IG51bGw7XG52YXIgbG9hZFNjcmlwdCA9IGZ1bmN0aW9uIGxvYWRTY3JpcHQocGFyYW1zKSB7XG4gIC8vIEVuc3VyZSB0aGF0IHdlIG9ubHkgYXR0ZW1wdCB0byBsb2FkIFN0cmlwZS5qcyBhdCBtb3N0IG9uY2VcbiAgaWYgKHN0cmlwZVByb21pc2UgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc3RyaXBlUHJvbWlzZTtcbiAgfVxuXG4gIHN0cmlwZVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJlc29sdmUgdG8gbnVsbCB3aGVuIGltcG9ydGVkIHNlcnZlciBzaWRlLiBUaGlzIG1ha2VzIHRoZSBtb2R1bGVcbiAgICAgIC8vIHNhZmUgdG8gaW1wb3J0IGluIGFuIGlzb21vcnBoaWMgY29kZSBiYXNlLlxuICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LlN0cmlwZSAmJiBwYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihFWElTVElOR19TQ1JJUFRfTUVTU0FHRSk7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5TdHJpcGUpIHtcbiAgICAgIHJlc29sdmUod2luZG93LlN0cmlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBzY3JpcHQgPSBmaW5kU2NyaXB0KCk7XG5cbiAgICAgIGlmIChzY3JpcHQgJiYgcGFyYW1zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihFWElTVElOR19TQ1JJUFRfTUVTU0FHRSk7XG4gICAgICB9IGVsc2UgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgc2NyaXB0ID0gaW5qZWN0U2NyaXB0KHBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAod2luZG93LlN0cmlwZSkge1xuICAgICAgICAgIHJlc29sdmUod2luZG93LlN0cmlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignU3RyaXBlLmpzIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBTdHJpcGUuanMnKSk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3RyaXBlUHJvbWlzZTtcbn07XG52YXIgaW5pdFN0cmlwZSA9IGZ1bmN0aW9uIGluaXRTdHJpcGUobWF5YmVTdHJpcGUsIGFyZ3MsIHN0YXJ0VGltZSkge1xuICBpZiAobWF5YmVTdHJpcGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzdHJpcGUgPSBtYXliZVN0cmlwZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICByZWdpc3RlcldyYXBwZXIoc3RyaXBlLCBzdGFydFRpbWUpO1xuICByZXR1cm4gc3RyaXBlO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcblxudmFyIHZhbGlkYXRlTG9hZFBhcmFtcyA9IGZ1bmN0aW9uIHZhbGlkYXRlTG9hZFBhcmFtcyhwYXJhbXMpIHtcbiAgdmFyIGVycm9yTWVzc2FnZSA9IFwiaW52YWxpZCBsb2FkIHBhcmFtZXRlcnM7IGV4cGVjdGVkIG9iamVjdCBvZiBzaGFwZVxcblxcbiAgICB7YWR2YW5jZWRGcmF1ZFNpZ25hbHM6IGJvb2xlYW59XFxuXFxuYnV0IHJlY2VpdmVkXFxuXFxuICAgIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShwYXJhbXMpLCBcIlxcblwiKTtcblxuICBpZiAocGFyYW1zID09PSBudWxsIHx8IF90eXBlb2YocGFyYW1zKSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgcGFyYW1zLmFkdmFuY2VkRnJhdWRTaWduYWxzID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG59O1xuXG52YXIgbG9hZFBhcmFtcztcbnZhciBsb2FkU3RyaXBlQ2FsbGVkID0gZmFsc2U7XG52YXIgbG9hZFN0cmlwZSA9IGZ1bmN0aW9uIGxvYWRTdHJpcGUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBsb2FkU3RyaXBlQ2FsbGVkID0gdHJ1ZTtcbiAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIHJldHVybiBsb2FkU2NyaXB0KGxvYWRQYXJhbXMpLnRoZW4oZnVuY3Rpb24gKG1heWJlU3RyaXBlKSB7XG4gICAgcmV0dXJuIGluaXRTdHJpcGUobWF5YmVTdHJpcGUsIGFyZ3MsIHN0YXJ0VGltZSk7XG4gIH0pO1xufTtcblxubG9hZFN0cmlwZS5zZXRMb2FkUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgLy8gd2Ugd29uJ3QgdGhyb3cgYW4gZXJyb3IgaWYgc2V0TG9hZFBhcmFtZXRlcnMgaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIGJlZm9yZVxuICBpZiAobG9hZFN0cmlwZUNhbGxlZCAmJiBsb2FkUGFyYW1zKSB7XG4gICAgdmFyIHZhbGlkYXRlZFBhcmFtcyA9IHZhbGlkYXRlTG9hZFBhcmFtcyhwYXJhbXMpO1xuICAgIHZhciBwYXJhbWV0ZXJLZXlzID0gT2JqZWN0LmtleXModmFsaWRhdGVkUGFyYW1zKTtcbiAgICB2YXIgc2FtZVBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJLZXlzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSB7XG4gICAgICB2YXIgX2xvYWRQYXJhbXM7XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlICYmIHBhcmFtc1tjdXJyZW50VmFsdWVdID09PSAoKF9sb2FkUGFyYW1zID0gbG9hZFBhcmFtcykgPT09IG51bGwgfHwgX2xvYWRQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sb2FkUGFyYW1zW2N1cnJlbnRWYWx1ZV0pO1xuICAgIH0sIHRydWUpO1xuXG4gICAgaWYgKHNhbWVQYXJhbWV0ZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvYWRTdHJpcGVDYWxsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgY2hhbmdlIGxvYWQgcGFyYW1ldGVycyBhZnRlciBjYWxsaW5nIGxvYWRTdHJpcGUnKTtcbiAgfVxuXG4gIGxvYWRQYXJhbXMgPSB2YWxpZGF0ZUxvYWRQYXJhbXMocGFyYW1zKTtcbn07XG5cbmV4cG9ydHMubG9hZFN0cmlwZSA9IGxvYWRTdHJpcGU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIlYzX1VSTCIsIlYzX1VSTF9SRUdFWCIsIkVYSVNUSU5HX1NDUklQVF9NRVNTQUdFIiwiZmluZFNjcmlwdCIsInNjcmlwdHMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjb25jYXQiLCJpIiwibGVuZ3RoIiwic2NyaXB0IiwidGVzdCIsInNyYyIsImluamVjdFNjcmlwdCIsInBhcmFtcyIsInF1ZXJ5U3RyaW5nIiwiYWR2YW5jZWRGcmF1ZFNpZ25hbHMiLCJjcmVhdGVFbGVtZW50IiwiaGVhZE9yQm9keSIsImhlYWQiLCJib2R5IiwiRXJyb3IiLCJhcHBlbmRDaGlsZCIsInJlZ2lzdGVyV3JhcHBlciIsInN0cmlwZSIsInN0YXJ0VGltZSIsIl9yZWdpc3RlcldyYXBwZXIiLCJuYW1lIiwidmVyc2lvbiIsInN0cmlwZVByb21pc2UiLCJsb2FkU2NyaXB0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ3aW5kb3ciLCJTdHJpcGUiLCJjb25zb2xlIiwid2FybiIsImFkZEV2ZW50TGlzdGVuZXIiLCJlcnJvciIsImluaXRTdHJpcGUiLCJtYXliZVN0cmlwZSIsImFyZ3MiLCJhcHBseSIsInVuZGVmaW5lZCIsInZhbGlkYXRlTG9hZFBhcmFtcyIsImVycm9yTWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJrZXlzIiwibG9hZFBhcmFtcyIsImxvYWRTdHJpcGVDYWxsZWQiLCJsb2FkU3RyaXBlIiwiX2xlbiIsImFyZ3VtZW50cyIsIkFycmF5IiwiX2tleSIsIkRhdGUiLCJub3ciLCJ0aGVuIiwic2V0TG9hZFBhcmFtZXRlcnMiLCJ2YWxpZGF0ZWRQYXJhbXMiLCJwYXJhbWV0ZXJLZXlzIiwic2FtZVBhcmFtZXRlcnMiLCJyZWR1Y2UiLCJwcmV2aW91c1ZhbHVlIiwiY3VycmVudFZhbHVlIiwiX2xvYWRQYXJhbXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/pure.js":
/*!************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/pure.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./dist/pure.js */ \"(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvcHVyZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLGlIQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xhbmRpbmdwYWdlLy4vbm9kZV9tb2R1bGVzL0BzdHJpcGUvc3RyaXBlLWpzL3B1cmUuanM/MTQ2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9wdXJlLmpzJyk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/pure.js\n");

/***/ })

};
;